local Plr = game:GetService('Players').LocalPlayer
local UseAnimate = false
local Char = Plr.Character
local F3X = Char:FindFirstChild("Building Tools")
if not F3X then
	repeat wait() until Char:FindFirstChild("Building Tools")
	F3X = Char:FindFirstChild("Building Tools")
end

local ServerEndpoint = F3X:WaitForChild("SyncAPI"):WaitForChild("ServerEndpoint")


function Request(...)
	return ServerEndpoint:InvokeServer(...)
end

local ToClone = {}
local BaseParts = {}


for i,v in ipairs(Char:GetChildren()) do
	if v:IsA("Humanoid") then
		ToClone[v.Name] = v
	end
end
for i,v in ipairs(Char:GetDescendants()) do
	if v:IsA("BasePart") then
		if v.Parent.ClassName == "Accessory" then
			BaseParts[v.Parent.Name] = v
			Request("SetName", unpack{
				table.pack(v),
				v.Parent.Name
			})
		else
			for i = 1, 6 do
				BaseParts[math.random()] = v
				Request("SetName", unpack{
					table.pack(v),
					v.Name
				})
			end
		end
	end
end

if workspace:FindFirstChild("ReAnimate - ".. Plr.Name) then
	Request("Remove", ({
		workspace:FindFirstChild("ReAnimate - ".. Plr.Name)
	}))
	for i,v in pairs(workspace:GetChildren()) do
		if v.Name == "ReAnimate" then
			Request("Remove", ({
				v
			}))
		end
	end
end

local Parts = Request("Clone",unpack({
	ToClone,
	workspace
}))

local ReAnimate = Request("CreateGroup", unpack({
	"Model",
	workspace,
	Parts
}))

local Cloned = Request("Clone",unpack({
	BaseParts,
	ReAnimate
}))

Request("SetName", unpack{
	table.pack(ReAnimate),
	"ReAnimate - ".. Plr.Name
})

for i,v in pairs(ToClone) do
	if true or not v:IsDescendantOf(ReAnimate) or v:IsDescendantOf(ReAnimate) then
		Request("SetParent", unpack{
			ToClone,
			ReAnimate
		})
	end
end

local BaseParts = Request("Clone",unpack{
	BaseParts,
	ReAnimate
})
local Clones = {}
for i,v in pairs(Char:GetChildren()) do
	if not ReAnimate:FindFirstChild(v) then
		table.insert(Clones, v)
	end
end

Request("Clone",unpack{
	Clones,
	ReAnimate
})

local Welds = {}

for i,Instance in ipairs(ReAnimate:GetDescendants()) do
	if Instance:IsA("BasePart") then
		Request("SyncResize", {{
			Part = Instance,
			CFrame = Instance.CFrame * CFrame.new(0,5,0),
			Size = Vector3.new(2,2,1),
		}})
		Request("SyncCollision", {{
			Part = Instance,
			CanCollide = false,
		}})
		Request("SyncAnchor", {{
			Part = Instance,
			Anchored = true
		}})
	end
end

for i = 1, 5 do
	BaseParts[1+i] = Request('Clone',unpack{{BaseParts[1]},ReAnimate})[1]
end

-- This script was generated by Hydroxide's RemoteSpy: https://github.com/Upbolt/Hydroxide

Request("SetLocked", unpack{
	BaseParts,
	true
})

Char.Archivable = true

PS = game:GetService('PhysicsService')


local FakeCharacter = Char:Clone()

FakeCharacter.Parent = workspace
FakeCharacter.Name = "CharacterMover"

local Humanoid = FakeCharacter:FindFirstChildOfClass("Humanoid")


local Collision = {}

game:GetService('RunService'):BindToRenderStep('collisionHandle', 199, function()
	for i,Table in pairs(Collision) do
		pcall(function()
			local Instance, CollisionEnabled = Table.Instance, Table.Collision
			Instance.CanCollide = CollisionEnabled
		end)
	end
end)

for i,v in pairs(FakeCharacter:GetDescendants()) do
	if v:IsA("BasePart") == true then
		v.Transparency = 0.9
		table.insert(Collision, {
			Instance = v,
			Collision = false,
		})
	end
end


for i,v in pairs(Char:GetDescendants()) do
	if v:IsA("BasePart") == true then
		Request("SyncAnchor", {{
			Part = v,
			Anchored = false
		}})
		table.insert(Collision, {
			Instance = v,
			Collision = false,
		})
	end
end


for i,v in pairs(Plr.Character:GetDescendants()) do
	if v:IsA("BasePart") or v:IsA("Decal") then
		Request("SyncMaterial", {{
			["Part"] = v,
			["Transparency"] = 0,
		}})
	end
end

local Camera = workspace.CurrentCamera

local UserInputService = game:GetService('UserInputService')

local Root = Instance.new("Part", workspace.Terrain)
Root.Name = "Root"
Root.Size = Vector3.new(1,1,1)
Root.CFrame = Char.HumanoidRootPart.CFrame
Root.Transparency = 1
Root.Color = Color3.new(1,0,0)
Root.Anchored = true
Root.CanCollide = false

for i,v in pairs(ReAnimate:GetChildren())do
	if v:IsA('BasePart') and v.Name == "Head" then
		task.spawn(function()
			ServerEndpoint:InvokeServer('SyncMesh', {
				[1] = {
					["Part"] = v,
					["MeshType"] = Enum.MeshType.Brick,
					["Scale"] = Vector3.new(1,1,1)
				}
			})
		end)
	end
end

Request("SyncResize", {{
	Part = Cloned[1],
	CFrame = Cloned[1].CFrame * CFrame.new(0,5,0),
	Size = Vector3.new(1,2,1),
}})

Request("SyncAnchor", {{
	Part = Cloned[1],
	Anchored = true
}})

Request("SetName", 
	Cloned,
	"What"
)


local NewIndex = Cloned[1]:GetChildren()



for i,v in pairs(NewIndex) do
	if string.match(v.ClassName, "Mesh") then
		table.remove(NewIndex, i)
	end
end

Request("Destroy", NewIndex)

Char.HumanoidRootPart.CFrame = CFrame.new(0,1e6,0)
Char.HumanoidRootPart.Anchored = true

Camera.CameraSubject = Root

FakeCharacter.HumanoidRootPart.CFrame = CFrame.new(0,100000,0)
FakeCharacter.HumanoidRootPart.Anchored = true

Plr.Character = FakeCharacter


local function KeyDown(Key)
	return not UserInputService:GetFocusedTextBox() and UserInputService:IsKeyDown(typeof(Key) == "EnumItem" and Key or Enum.KeyCode[Key]) or false
end
Angle = CFrame.Angles(0,0,0)
LastFrame = tick()
WalkSpeed = 16
ToChange = {}
FakeParts = {}
Offset = {}
ToChange[1] = {
	Part = nil,
	CFrame = CFrame.new(),
	Size = Vector3.new(2,2,1)
}
ToChange[2] = {
	Part = nil,
	CFrame = CFrame.new(),
	Size = Vector3.new(1,2,1)
}
ToChange[3] = {
	Part = nil,
	CFrame = CFrame.new(),
	Size = Vector3.new(1,2,1)
}
ToChange[4] = {
	Part = nil,
	CFrame = CFrame.new(),
	Size = Vector3.new(1,2,1)
}
ToChange[5] = {
	Part = nil,
	CFrame = CFrame.new(),
	Size = Vector3.new(1,2,1)
}
ToChange[6] = {
	Part = nil,
	CFrame = CFrame.new(),
	Size = Vector3.new(1,1,1)
}
RootCFrame = CFrame.new()
Sine= 0
LastRoot = RootCFrame
LastFrame = tick()
Add = 0
-- bye bye molly :[ youll be missed
local ids = {
	'rbxassetid://7037264869', -- the infamous images/zzz
	'rbxassetid://7037156897', -- moller circular
	'rbxassetid://7043731194', -- molly mug
	'rbxassetid://7037269561', -- devil dog (will kill you if you do not repost)
	'rbxassetid://7037272153', -- mollerOS logo
	'rbxassetid://7037339934', -- molge
	'rbxassetid://7037356929', -- idk what this is but its funny
	'rbxassetid://7044042331', -- mollersuite/moller hub logo before it got turned monocolor
	'rbxassetid://7044088926', -- seconds before "bragle" was taken
	'rbxassetid://7046289590' -- she wants your food
}
local HRP = {CFrame = CFrame.new(), LastCFrame = CFrame.new()}
local hcf,tcf,lacf,racf,rlcf,llcf=CFrame.new(),CFrame.new(),CFrame.new(),CFrame.new(),CFrame.new(),CFrame.new()
game:GetService('RunService').Heartbeat:Connect(function(deltaTime)
	Sine += deltaTime * 30
	Speed = -(tick() - LastFrame) *- 25 + Add
	HRP.LastCFrame = RootCFrame
	if KeyDown("W") then
		RootCFrame *= CFrame.new(0,0,-1*Speed)
	end
	if KeyDown("S") then
		RootCFrame *= CFrame.new(0,0,1*Speed)
	end
	if KeyDown("A") then
		RootCFrame *= CFrame.new(-1*Speed,0,0)
	end
	if KeyDown("D") then
		RootCFrame *= CFrame.new(1*Speed,0,0)
	end
	if (RootCFrame.Position.X ~= LastRoot.Position.X or RootCFrame.Position.Z ~= LastRoot.Position.Z) then
		RootCFrame = CFrame.new(RootCFrame.Position, RootCFrame.Position + workspace.CurrentCamera.CFrame.LookVector)
		HRP.CFrame = RootCFrame
	else
		Add = 0
	end
	LastFrame = tick()
	LastRoot = RootCFrame
	LastFrame = tick()
	local sine = Sine
	local Ccf = RootCFrame
	local MoveDirection = HRP.CFrame.Position - HRP.LastCFrame.Position
	local Ccf = HRP.CFrame
	local Walktest1 = MoveDirection*Ccf.LookVector
	local Walktest2 = MoveDirection*Ccf.RightVector
	local ForwardBack = Walktest1.X+Walktest1.Z
	local RightLeft = Walktest2.X+Walktest2.Z
	if HRP.CFrame ~= HRP.LastCFrame then
		hcf = hcf:Lerp(CFrame.new(0.002, 1.5+0.05*math.cos(sine/20), 0.056) * CFrame.Angles(math.rad(75.06*ForwardBack), math.rad(13.03), math.rad(0)),.1)
		tcf = tcf:Lerp(CFrame.new(0.002-0.5*math.sin(sine/20), 0.441+0.5*math.cos(sine/20), 0.004-0.05*math.cos(sine/20)) * CFrame.Angles(math.rad(-65.06*ForwardBack), math.rad(7.94), math.rad(-RightLeft*50))*CFrame.new(0,0.5*math.cos(sine/20),0),.1)
		lacf = lacf:Lerp(CFrame.new(-1.498, 0+0.05*math.cos(sine/30), 0.5*ForwardBack) * CFrame.Angles(math.rad(-120*ForwardBack),math.rad(0+math.cos(sine/50)),math.rad(0+math.cos(sine*2/50))),.1)
		racf = racf:Lerp(CFrame.new(1.186, 0+0.05*math.cos(sine/30), 0.673) * CFrame.Angles(math.rad(-31.84+math.cos(sine/30)), math.rad(-65.76+math.cos(sine/50)), math.rad(-17.59+math.cos(sine*2/50))),.1)
		rlcf = rlcf:Lerp(CFrame.new(0.571, -1.559+0.05*math.cos(sine/30), -0.248) * CFrame.Angles(math.rad(-11.25+math.cos(sine/30)), math.rad(-6.41+math.cos(sine/50)), math.rad(0+math.cos(sine*2/50))),.1)
		llcf = llcf:Lerp(CFrame.new(-0.573, -1.127+0.05*math.cos(sine/30), -0.576) * CFrame.Angles(math.rad(-14.41+math.cos(sine/30)), math.rad(8.49+math.cos(sine/50)), math.rad(0+math.cos(sine*2/50))),.1)
	else
		hcf = hcf:Lerp(CFrame.new(0.002, 1.5+0.05*math.cos(sine/20), 0.056) * CFrame.Angles(math.rad(-6.06), math.rad(13.03), math.rad(0)),.1)
		tcf = tcf:Lerp(CFrame.new(0.002-0.5*math.sin(sine/20), 0.441+0.5*math.cos(sine/20), 0.004-0.05*math.cos(sine/20)) * CFrame.Angles(math.rad(13.24+2*math.sin(sine/20)), math.rad(7.94), math.rad(0))*CFrame.new(0,0.5*math.cos(sine/20),0),.1)
		lacf = lacf:Lerp(CFrame.new(-1.498, 0+0.05*math.cos(sine/30), -0.25) * CFrame.Angles(math.rad(5.4+math.cos(sine/30)),math.rad(0+math.cos(sine/50)),math.rad(0+math.cos(sine*2/50))),.1)
		racf = racf:Lerp(CFrame.new(1.186, 0+0.05*math.cos(sine/30), 0.673) * CFrame.Angles(math.rad(-31.84+math.cos(sine/30)), math.rad(-65.76+math.cos(sine/50)), math.rad(-17.59+math.cos(sine*2/50))),.1)
		rlcf = rlcf:Lerp(CFrame.new(0.571, -1.559+0.05*math.cos(sine/30), -0.248) * CFrame.Angles(math.rad(-11.25+math.cos(sine/30)), math.rad(-6.41+math.cos(sine/50)), math.rad(0+math.cos(sine*2/50))),.1)
		llcf = llcf:Lerp(CFrame.new(-0.573, -1.127+0.05*math.cos(sine/30), -0.576) * CFrame.Angles(math.rad(-14.41+math.cos(sine/30)), math.rad(8.49+math.cos(sine/50)), math.rad(0+math.cos(sine*2/50))),.1)
	end
	ToChange[1].Part = BaseParts[1]
	ToChange[1].CFrame = ToChange[1].CFrame:Lerp(RootCFrame * tcf,0.45)
	ToChange[2].Part = BaseParts[2]
	ToChange[2].CFrame = ToChange[2].CFrame:Lerp(RootCFrame * tcf * racf,0.45)
	ToChange[3].Part = BaseParts[3]
	ToChange[3].CFrame = ToChange[3].CFrame:Lerp(RootCFrame * tcf * lacf,0.45)
	ToChange[4].Part = BaseParts[4]
	ToChange[4].CFrame = ToChange[4].CFrame:Lerp(RootCFrame * tcf * rlcf,0.45)
	ToChange[5].Part = BaseParts[5]
	ToChange[5].CFrame = ToChange[5].CFrame:Lerp(RootCFrame * tcf * llcf,0.45)
	ToChange[6].Part = Cloned[1]
	ToChange[6].CFrame = ToChange[6].CFrame:Lerp(RootCFrame * tcf * hcf,0.45)
	Root.CFrame = BaseParts[1].CFrame
	Request("SyncResize", ToChange)
end)

Mouse = Plr:GetMouse()

UserInputService.InputBegan:Connect(function(InputObject, GameProcessed)
	if GameProcessed then
		return
	end
	local Key = InputObject.KeyCode.Name
	local InputType = InputObject.UserInputType.Name
	if InputType == Enum.UserInputType.MouseButton1.Name then
		if Mouse.Target and Mouse.Target:IsA("BasePart") then
			if Mouse.Target ~=BaseParts[1] and not string.match((Mouse.Target.Name), "Base") and not string.match((Mouse.Target.Name), "ReAnimate - ") then
				local Part = Mouse.Target
				Request("SyncResize", {
					[1] = {
						Part = Part,
						Size = Part.Size,
						CFrame = CFrame.new(0,1e6,0)
					}
				})
				Request("SyncAnchor", {{
					Part = Part,
					Anchored = true
				}})
			end
		end
	end
end)
local A = {}
task.spawn(function()
	while wait() do
		for i,v in pairs(ReAnimate:GetChildren()) do
			if not table.find(A,v) then
				table.insert(A,v)
				Request("SyncMaterial", {{
					["Part"] = v,
					Material = "Glass",
					Color = Color3.fromHSV(math.random(),1,1),
					Transparency = 0,
				}})
				Request("SyncColor",{{
					["Part"] = v,
					Color = Color3.fromHSV(math.random(),1,0.1)
				}})
			else
				Request("SyncMaterial", {{
					["Part"] = v,
					Material = "Glass",
					Color = Color3.fromHSV(math.random(),1,1),
					Transparency = 0,
				}})
				Request("SyncColor",{{
					["Part"] = v,
					Color = Color3.fromHSV(math.random(),1,0.1)
				}})
			end
		end
	end
end)
